<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NovelRT: NovelRT::Ecs::ComponentBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "ams.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="left-align-mathjax.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="novel-chan-header_doxy.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NovelRT
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">NovelRT game engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>NovelRT</b></li><li class="navelem"><a class="el" href="namespace_novel_r_t_1_1_ecs.html">Ecs</a></li><li class="navelem"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">ComponentBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_novel_r_t_1_1_ecs_1_1_component_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NovelRT::Ecs::ComponentBuffer&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A storage type that manages the storage and modification of the given type concurrently.  
 <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_component_buffer_8h_source.html">ComponentBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3f819d8d44974883a02b5a4970cbfd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#ac3f819d8d44974883a02b5a4970cbfd7">ComponentBuffer</a> (size_t poolSize, T deleteInstructionState, const std::string &amp;serialisedTypeName) noexcept</td></tr>
<tr class="memdesc:ac3f819d8d44974883a02b5a4970cbfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> for type T.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#ac3f819d8d44974883a02b5a4970cbfd7">More...</a><br /></td></tr>
<tr class="separator:ac3f819d8d44974883a02b5a4970cbfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b93cfdf0e75ce421e323482ab967a9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a0b93cfdf0e75ce421e323482ab967a9e">ComponentBuffer</a> (std::shared_ptr&lt; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> &gt; innerContainer) noexcept</td></tr>
<tr class="memdesc:a0b93cfdf0e75ce421e323482ab967a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> with an existing <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> as the underlying memory store.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a0b93cfdf0e75ce421e323482ab967a9e">More...</a><br /></td></tr>
<tr class="separator:a0b93cfdf0e75ce421e323482ab967a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d56ad382a686a0517477ed3a988c25"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a51d56ad382a686a0517477ed3a988c25">GetUnderlyingContainer</a> () const noexcept</td></tr>
<tr class="memdesc:a51d56ad382a686a0517477ed3a988c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the underlying <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> associated with this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instance.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a51d56ad382a686a0517477ed3a988c25">More...</a><br /></td></tr>
<tr class="separator:a51d56ad382a686a0517477ed3a988c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3df200354138fa2a9fbdfd41c3bd6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a6f3df200354138fa2a9fbdfd41c3bd6d">PrepComponentBufferForFrame</a> (const std::vector&lt; EntityId &gt; &amp;destroyedEntities) noexcept</td></tr>
<tr class="memdesc:a6f3df200354138fa2a9fbdfd41c3bd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles all modification instructions from all threads and clears the instruction sets in preparation for new instructions incoming for the next update iteration.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a6f3df200354138fa2a9fbdfd41c3bd6d">More...</a><br /></td></tr>
<tr class="separator:a6f3df200354138fa2a9fbdfd41c3bd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b00ffe758e18df83bd1b20dd460ae3a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a2b00ffe758e18df83bd1b20dd460ae3a">GetDeleteInstructionState</a> () const noexcept</td></tr>
<tr class="memdesc:a2b00ffe758e18df83bd1b20dd460ae3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the delete instruction state for type T.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a2b00ffe758e18df83bd1b20dd460ae3a">More...</a><br /></td></tr>
<tr class="separator:a2b00ffe758e18df83bd1b20dd460ae3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d37e7e1e1f4396902ffbcf52dd760ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a1d37e7e1e1f4396902ffbcf52dd760ff">PushComponentUpdateInstruction</a> (size_t poolId, EntityId entity, T component)</td></tr>
<tr class="memdesc:a1d37e7e1e1f4396902ffbcf52dd760ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes in an update instruction for the given entity, component and thread pool ID.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a1d37e7e1e1f4396902ffbcf52dd760ff">More...</a><br /></td></tr>
<tr class="separator:a1d37e7e1e1f4396902ffbcf52dd760ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692c364f2f9fccd89365c60a19ee7295"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a692c364f2f9fccd89365c60a19ee7295">GetComponent</a> (EntityId entity) const</td></tr>
<tr class="memdesc:a692c364f2f9fccd89365c60a19ee7295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a copy of the component instance attached to this entity.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a692c364f2f9fccd89365c60a19ee7295">More...</a><br /></td></tr>
<tr class="separator:a692c364f2f9fccd89365c60a19ee7295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ac5926fab49a4378f791825072e953"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#ad1ac5926fab49a4378f791825072e953">TryGetComponent</a> (EntityId entity, T &amp;outComponent) const noexcept</td></tr>
<tr class="memdesc:ad1ac5926fab49a4378f791825072e953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get the component instance attached to this entity.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#ad1ac5926fab49a4378f791825072e953">More...</a><br /></td></tr>
<tr class="separator:ad1ac5926fab49a4378f791825072e953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1b64c5514d251039336b71c71cd8f6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#aaf1b64c5514d251039336b71c71cd8f6">GetComponentUnsafe</a> (EntityId entity) const noexcept</td></tr>
<tr class="memdesc:aaf1b64c5514d251039336b71c71cd8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a copy of the component instance attached to this entity.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#aaf1b64c5514d251039336b71c71cd8f6">More...</a><br /></td></tr>
<tr class="separator:aaf1b64c5514d251039336b71c71cd8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0afee7bdd935cab3669c46ee65ea1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a5e0afee7bdd935cab3669c46ee65ea1a">HasComponent</a> (EntityId entity) const noexcept</td></tr>
<tr class="memdesc:a5e0afee7bdd935cab3669c46ee65ea1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if a given entity has a component.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a5e0afee7bdd935cab3669c46ee65ea1a">More...</a><br /></td></tr>
<tr class="separator:a5e0afee7bdd935cab3669c46ee65ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8b9e7d18f7b76a9b879e62191e04a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a17d8b9e7d18f7b76a9b879e62191e04a">GetSerialisedTypeName</a> () const noexcept</td></tr>
<tr class="memdesc:a17d8b9e7d18f7b76a9b879e62191e04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the serialised type name used for the loading and unloading to and from serialised data.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a17d8b9e7d18f7b76a9b879e62191e04a">More...</a><br /></td></tr>
<tr class="separator:a17d8b9e7d18f7b76a9b879e62191e04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5001cab249a11a167017e6fe3a4b82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#aba5001cab249a11a167017e6fe3a4b82">GetImmutableDataLength</a> () const noexcept</td></tr>
<tr class="memdesc:aba5001cab249a11a167017e6fe3a4b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the current immutable data snapshot within the buffer.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#aba5001cab249a11a167017e6fe3a4b82">More...</a><br /></td></tr>
<tr class="separator:aba5001cab249a11a167017e6fe3a4b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d36984431577ec1f0052833aa3fc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; EntityId, T &gt;::ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#aa1d36984431577ec1f0052833aa3fc6d">begin</a> () const noexcept</td></tr>
<tr class="memdesc:aa1d36984431577ec1f0052833aa3fc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the beginning forward const iterator state for the immutable data in this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#aa1d36984431577ec1f0052833aa3fc6d">More...</a><br /></td></tr>
<tr class="separator:aa1d36984431577ec1f0052833aa3fc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f6194df0442ed7c84cf7eeff42a313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; EntityId, T &gt;::ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a03f6194df0442ed7c84cf7eeff42a313">end</a> () const noexcept</td></tr>
<tr class="memdesc:a03f6194df0442ed7c84cf7eeff42a313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the end forward const iterator state for the immutable data in this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a03f6194df0442ed7c84cf7eeff42a313">More...</a><br /></td></tr>
<tr class="separator:a03f6194df0442ed7c84cf7eeff42a313"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class NovelRT::Ecs::ComponentBuffer&lt; T &gt;</h3>

<p>A storage type that manages the storage and modification of the given type concurrently. </p>
<p>You should not be instantiating this yourself in a regular setup.</p>
<p>Please note that this storage type assumes that the component in question is a simple struct at all times. You should not have component types that are massively complex as there may be many copy instructions that are not SIMDifiable if the type is too complicated. The type T of the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> must be trivially copyable as defined by the C++ language reference. This is due to the internal language binding mechanisms of NovelRT, and is enforced by a check against std::is_trivally_copyable. The type in question will need to have addition and an equality comparison operator implemented in order for it to function as a type a <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> can manage for you.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of component this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> will manage. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3f819d8d44974883a02b5a4970cbfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f819d8d44974883a02b5a4970cbfd7">&#9670;&nbsp;</a></span>ComponentBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">ComponentBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>deleteInstructionState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serialisedTypeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> for type T. </p>
<p>In a regular ECS setup, you should not be instantiating this yourself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolSize</td><td>The amount of worker threads being utilised in this instance of the ECS. </td></tr>
    <tr><td class="paramname">serialisedTypeName</td><td>The type name to use for serialisation of this data type. </td></tr>
    <tr><td class="paramname">deleteInstructionState</td><td>The component state to treat as the delete instruction. When this state is passed in during an update, the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> will delete the component from the target entity during resolution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b93cfdf0e75ce421e323482ab967a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b93cfdf0e75ce421e323482ab967a9e">&#9670;&nbsp;</a></span>ComponentBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">ComponentBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> &gt;&#160;</td>
          <td class="paramname"><em>innerContainer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> with an existing <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> as the underlying memory store. </p>
<p>In a regular ECS setup, you should not be instantiating this yourself.</p>
<p>This is an unsafe operation. Memory containers do not persist any form of type safety. Please ensure that type T is either the same as, or is compatible with, the underlying data. If a container is supplied that does not match type T then the behaviour of the entire object is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">innerContainer</td><td>The container to base this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1d36984431577ec1f0052833aa3fc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d36984431577ec1f0052833aa3fc6d">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;EntityId, T&gt;::ConstIterator <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the beginning forward const iterator state for the immutable data in this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html" title="A const iterator for traversing the keys and values of this particular SparseSet as tuple pairs in a ...">SparseSet::ConstIterator</a> starting at the beginning. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_aa1d36984431577ec1f0052833aa3fc6d_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_aa1d36984431577ec1f0052833aa3fc6d_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_aa1d36984431577ec1f0052833aa3fc6d_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_aa1d36984431577ec1f0052833aa3fc6d_icgraph">
<area shape="rect" title="Gets the beginning forward const iterator state for the immutable data in this ComponentBuffer." alt="" coords="273,5,500,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a60a1b2e37c1d84fd328193e96c71ae8a" title="Gets the beginning forward const iterator state for the immutable data from the underlying ComponentB..." alt="" coords="5,5,225,47"/>
</map>
</div>

</div>
</div>
<a id="a03f6194df0442ed7c84cf7eeff42a313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f6194df0442ed7c84cf7eeff42a313">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;EntityId, T&gt;::ConstIterator <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the end forward const iterator state for the immutable data in this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html" title="A const iterator for traversing the keys and values of this particular SparseSet as tuple pairs in a ...">SparseSet::ConstIterator</a> starting at the end. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_a03f6194df0442ed7c84cf7eeff42a313_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_a03f6194df0442ed7c84cf7eeff42a313_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_a03f6194df0442ed7c84cf7eeff42a313_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_a03f6194df0442ed7c84cf7eeff42a313_icgraph">
<area shape="rect" title="Gets the end forward const iterator state for the immutable data in this ComponentBuffer." alt="" coords="304,5,563,32"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a1c10fc4b320a3b8682cbe20758c928b4" title="Gets the end forward const iterator state for the immutable data from the underlying ComponentBuffer." alt="" coords="5,5,256,32"/>
</map>
</div>

</div>
</div>
<a id="a692c364f2f9fccd89365c60a19ee7295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692c364f2f9fccd89365c60a19ee7295">&#9670;&nbsp;</a></span>GetComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::GetComponent </td>
          <td>(</td>
          <td class="paramtype">EntityId&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a copy of the component instance attached to this entity. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>The entity to use for fetching the component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current state of the component of type T attached to the given entity. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_novel_r_t_1_1_exceptions_1_1_key_not_found_exception.html">Exceptions::KeyNotFoundException</a></td><td>if the given EntityId is not present within the set. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_a692c364f2f9fccd89365c60a19ee7295_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_a692c364f2f9fccd89365c60a19ee7295_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_a692c364f2f9fccd89365c60a19ee7295_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_a692c364f2f9fccd89365c60a19ee7295_icgraph">
<area shape="rect" title="Gets a copy of the component instance attached to this entity." alt="" coords="273,5,500,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a45687e737cd3b1f32e19aaeb225f9947" title="Gets a copy of the component instance attached to this entity." alt="" coords="5,5,225,47"/>
</map>
</div>

</div>
</div>
<a id="aaf1b64c5514d251039336b71c71cd8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1b64c5514d251039336b71c71cd8f6">&#9670;&nbsp;</a></span>GetComponentUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::GetComponentUnsafe </td>
          <td>(</td>
          <td class="paramtype">EntityId&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a copy of the component instance attached to this entity. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method. This is considered an unsafe operation. Before calling this, you must guarantee that the provided entity exists in the read-only portion of the underlying buffer. Please see <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#a5e0afee7bdd935cab3669c46ee65ea1a" title="Verifies if a given entity has a component.">ComponentBuffer::HasComponent</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>The entity to use for fetching the component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the current state of the component of type T attached to the given entity. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_aaf1b64c5514d251039336b71c71cd8f6_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_aaf1b64c5514d251039336b71c71cd8f6_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_aaf1b64c5514d251039336b71c71cd8f6_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_aaf1b64c5514d251039336b71c71cd8f6_icgraph">
<area shape="rect" title="Gets a copy of the component instance attached to this entity." alt="" coords="312,39,539,80"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a02faba45ddb1608481305cfcf6b3a8d6" title="Gets a copy of the component instance attached to this entity." alt="" coords="25,5,245,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#ad1ac5926fab49a4378f791825072e953" title="Attempts to get the component instance attached to this entity." alt="" coords="5,71,264,112"/>
</map>
</div>

</div>
</div>
<a id="a2b00ffe758e18df83bd1b20dd460ae3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b00ffe758e18df83bd1b20dd460ae3a">&#9670;&nbsp;</a></span>GetDeleteInstructionState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::GetDeleteInstructionState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the delete instruction state for type T. </p>
<p>If this state is pushed in as an update instruction, the entity in question will no longer have this component attached and the component will be deleted. This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd>T in the specified state that represents deletion. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_a2b00ffe758e18df83bd1b20dd460ae3a_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_a2b00ffe758e18df83bd1b20dd460ae3a_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_a2b00ffe758e18df83bd1b20dd460ae3a_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_a2b00ffe758e18df83bd1b20dd460ae3a_icgraph">
<area shape="rect" title="Gets the delete instruction state for type T." alt="" coords="541,39,768,80"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a1b57d235481d3bfbc0b8e832f101287e" title="Gets the immutable component state for a delete instruction." alt="" coords="273,5,493,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#affa086e04bd8bf538ab315b69b8818bb" title="Removes the specified component type from a given entity." alt="" coords="273,71,493,112"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a0230d7f5e387c84c77d58260280f3051" title="Attempts to remove a component from an entity with safety checks to ensure it is an exceptionless ope..." alt="" coords="5,71,225,112"/>
</map>
</div>

</div>
</div>
<a id="aba5001cab249a11a167017e6fe3a4b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5001cab249a11a167017e6fe3a4b82">&#9670;&nbsp;</a></span>GetImmutableDataLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::GetImmutableDataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the length of the current immutable data snapshot within the buffer. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd>The length of the data. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_aba5001cab249a11a167017e6fe3a4b82_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_aba5001cab249a11a167017e6fe3a4b82_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_aba5001cab249a11a167017e6fe3a4b82_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_aba5001cab249a11a167017e6fe3a4b82_icgraph">
<area shape="rect" title="Gets the length of the current immutable data snapshot within the buffer." alt="" coords="273,5,500,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#acdb54c72f0a8ce9207ab42b0eabbdaeb" title="Gets the length of the current immutable data snapshot within the buffer." alt="" coords="5,5,225,47"/>
</map>
</div>

</div>
</div>
<a id="a17d8b9e7d18f7b76a9b879e62191e04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d8b9e7d18f7b76a9b879e62191e04a">&#9670;&nbsp;</a></span>GetSerialisedTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::GetSerialisedTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the serialised type name used for the loading and unloading to and from serialised data. </p>
<dl class="section return"><dt>Returns</dt><dd>The serialised type name as a string. </dd></dl>

</div>
</div>
<a id="a51d56ad382a686a0517477ed3a988c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d56ad382a686a0517477ed3a988c25">&#9670;&nbsp;</a></span>GetUnderlyingContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a>&gt; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::GetUnderlyingContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the underlying <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> associated with this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instance. </p>
<p>Accessing the underlying memory container is considered an unsafe operation. In a regular ECS scenario, you should not need to access it. This is a pure method. Calling this without using the result has no effect and introduces the overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd>The underlying container. </dd></dl>

</div>
</div>
<a id="a5e0afee7bdd935cab3669c46ee65ea1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0afee7bdd935cab3669c46ee65ea1a">&#9670;&nbsp;</a></span>HasComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::HasComponent </td>
          <td>(</td>
          <td class="paramtype">EntityId&#160;</td>
          <td class="paramname"><em>entity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies if a given entity has a component. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>The target entity to check for an attached component on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the immutable data contains the given EntityId. </dd>
<dd>
false if there is no entry for the given EntityId. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_a5e0afee7bdd935cab3669c46ee65ea1a_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_a5e0afee7bdd935cab3669c46ee65ea1a_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_a5e0afee7bdd935cab3669c46ee65ea1a_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_a5e0afee7bdd935cab3669c46ee65ea1a_icgraph">
<area shape="rect" title="Verifies if a given entity has a component." alt="" coords="312,71,539,112"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#ab2a2c9edae3be4cc3a24d5efc24d3a3c" title="Verifies if a given entity has a component." alt="" coords="25,5,245,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html#ad1ac5926fab49a4378f791825072e953" title="Attempts to get the component instance attached to this entity." alt="" coords="5,71,264,112"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a0230d7f5e387c84c77d58260280f3051" title="Attempts to remove a component from an entity with safety checks to ensure it is an exceptionless ope..." alt="" coords="25,136,245,177"/>
</map>
</div>

</div>
</div>
<a id="a6f3df200354138fa2a9fbdfd41c3bd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3df200354138fa2a9fbdfd41c3bd6d">&#9670;&nbsp;</a></span>PrepComponentBufferForFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::PrepComponentBufferForFrame </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; EntityId &gt; &amp;&#160;</td>
          <td class="paramname"><em>destroyedEntities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles all modification instructions from all threads and clears the instruction sets in preparation for new instructions incoming for the next update iteration. </p>
<p>In a regular ECS setup, you should not have to call this yourself. Please also note that this is not thread safe. Usually, this method is only called by the main thread, and only while no work is currently being processed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destroyedEntities</td><td>The entities that have been explicitly destroyed by all worker threads during the last update cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d37e7e1e1f4396902ffbcf52dd760ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d37e7e1e1f4396902ffbcf52dd760ff">&#9670;&nbsp;</a></span>PushComponentUpdateInstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::PushComponentUpdateInstruction </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poolId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EntityId&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes in an update instruction for the given entity, component and thread pool ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolId</td><td>The pool ID associated with the thread attempting to push the update instruction. </td></tr>
    <tr><td class="paramname">entity</td><td>The target entity within this particular ECS instance. </td></tr>
    <tr><td class="paramname">component</td><td>The instruction as a component state. This should represent the modification you wish to make, as opposed to a final state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_novel_r_t_1_1_exceptions_1_1_duplicate_key_exception.html">Exceptions::DuplicateKeyException</a></td><td>if multiple updates to the same entity are pushed. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if an invalid poolId is provided. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_a1d37e7e1e1f4396902ffbcf52dd760ff_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_a1d37e7e1e1f4396902ffbcf52dd760ff_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_a1d37e7e1e1f4396902ffbcf52dd760ff_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_a1d37e7e1e1f4396902ffbcf52dd760ff_icgraph">
<area shape="rect" title="Pushes in an update instruction for the given entity, component and thread pool ID." alt="" coords="841,5,1093,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a2fd2a2e8141357fd203f78c15a6b05f5" title="Pushes a new Component state as an update instruction into the ComponentBuffer with the current threa..." alt="" coords="541,5,793,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#affa086e04bd8bf538ab315b69b8818bb" title="Removes the specified component type from a given entity." alt="" coords="273,5,493,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a0230d7f5e387c84c77d58260280f3051" title="Attempts to remove a component from an entity with safety checks to ensure it is an exceptionless ope..." alt="" coords="5,5,225,47"/>
</map>
</div>

</div>
</div>
<a id="ad1ac5926fab49a4378f791825072e953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ac5926fab49a4378f791825072e953">&#9670;&nbsp;</a></span>TryGetComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">NovelRT::Ecs::ComponentBuffer</a>&lt; T &gt;::TryGetComponent </td>
          <td>(</td>
          <td class="paramtype">EntityId&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>outComponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to get the component instance attached to this entity. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>The entity to use for fetching the component. </td></tr>
    <tr><td class="paramname">outComponent</td><td>The output result for the fetched component, if there is one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a component was found and returned in outComponent. </dd>
<dd>
false if no component exists. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_buffer_ad1ac5926fab49a4378f791825072e953_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_buffer_ad1ac5926fab49a4378f791825072e953_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_buffer_ad1ac5926fab49a4378f791825072e953_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_buffer_ad1ac5926fab49a4378f791825072e953_icgraph">
<area shape="rect" title="Attempts to get the component instance attached to this entity." alt="" coords="273,5,500,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_component_view.html#a22627c2a1a8600924bd2af1142811018" title="Attempts to get the component instance attached to this entity." alt="" coords="5,5,225,47"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/NovelRT/NovelRT/include/NovelRT/Ecs/<a class="el" href="_component_buffer_8h_source.html">ComponentBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
