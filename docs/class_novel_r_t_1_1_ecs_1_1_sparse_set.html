<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NovelRT: NovelRT::Ecs::SparseSet&lt; TKey, TValue &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="novel-chan-header_doxy.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NovelRT
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">NovelRT game engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>NovelRT</b></li><li class="navelem"><a class="el" href="namespace_novel_r_t_1_1_ecs.html">Ecs</a></li><li class="navelem"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_novel_r_t_1_1_ecs_1_1_sparse_set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NovelRT::Ecs::SparseSet&lt; TKey, TValue &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A custom sparse set implementation designed at storing small, blittable types.  
 <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sparse_set_8h_source.html">SparseSet.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator for traversing the keys and values of this particular <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> as tuple pairs in a read-only fashion.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non const iterator for traversing the keys and values of this particular <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> as tuple pairs.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a59b52b632d8cc44edef33719499aa837"><td class="memItemLeft" align="right" valign="top"><a id="a59b52b632d8cc44edef33719499aa837"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a59b52b632d8cc44edef33719499aa837">SparseSet</a> () noexcept</td></tr>
<tr class="memdesc:a59b52b632d8cc44edef33719499aa837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new instance of <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> with the given type parameters. <br /></td></tr>
<tr class="separator:a59b52b632d8cc44edef33719499aa837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eaf3e39edcd8243219a6cba720ea80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a41eaf3e39edcd8243219a6cba720ea80">Insert</a> (TKey key, TValue value)</td></tr>
<tr class="memdesc:a41eaf3e39edcd8243219a6cba720ea80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new key with paired with an initial value into the set.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a41eaf3e39edcd8243219a6cba720ea80">More...</a><br /></td></tr>
<tr class="separator:a41eaf3e39edcd8243219a6cba720ea80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34037a5d3a1d547dfef08a0f51405d49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a34037a5d3a1d547dfef08a0f51405d49">TryInsert</a> (TKey key, TValue value) noexcept</td></tr>
<tr class="memdesc:a34037a5d3a1d547dfef08a0f51405d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to insert a new key paired with an initial value into the set.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a34037a5d3a1d547dfef08a0f51405d49">More...</a><br /></td></tr>
<tr class="separator:a34037a5d3a1d547dfef08a0f51405d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b85d25c0f3b52f08075c95b0875358a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a4b85d25c0f3b52f08075c95b0875358a">Remove</a> (TKey key)</td></tr>
<tr class="memdesc:a4b85d25c0f3b52f08075c95b0875358a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a given key and its associated value from the set.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a4b85d25c0f3b52f08075c95b0875358a">More...</a><br /></td></tr>
<tr class="separator:a4b85d25c0f3b52f08075c95b0875358a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccd7c783239892626a5f3ea6fa0eaab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a8ccd7c783239892626a5f3ea6fa0eaab">TryRemove</a> (TKey key) noexcept</td></tr>
<tr class="memdesc:a8ccd7c783239892626a5f3ea6fa0eaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to remove the given key from the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> with additional safety checks to ensure it is an exceptionless operation.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a8ccd7c783239892626a5f3ea6fa0eaab">More...</a><br /></td></tr>
<tr class="separator:a8ccd7c783239892626a5f3ea6fa0eaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd802995eead07787266ded0da611b65"><td class="memItemLeft" align="right" valign="top"><a id="afd802995eead07787266ded0da611b65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#afd802995eead07787266ded0da611b65">Clear</a> () noexcept</td></tr>
<tr class="memdesc:afd802995eead07787266ded0da611b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all data from the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. <br /></td></tr>
<tr class="separator:afd802995eead07787266ded0da611b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273330ecc7422f2791d83899e48e7e9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a273330ecc7422f2791d83899e48e7e9e">ContainsKey</a> (TKey key) const noexcept</td></tr>
<tr class="memdesc:a273330ecc7422f2791d83899e48e7e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the key is present within the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a273330ecc7422f2791d83899e48e7e9e">More...</a><br /></td></tr>
<tr class="separator:a273330ecc7422f2791d83899e48e7e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c7e95c1f6e5e8eb1a7f491baece051"><td class="memItemLeft" align="right" valign="top">TKey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a56c7e95c1f6e5e8eb1a7f491baece051">CopyKeyBasedOnDenseIndex</a> (size_t denseIndex) const</td></tr>
<tr class="memdesc:a56c7e95c1f6e5e8eb1a7f491baece051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the key out of the sparse set at the given dense index.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a56c7e95c1f6e5e8eb1a7f491baece051">More...</a><br /></td></tr>
<tr class="separator:a56c7e95c1f6e5e8eb1a7f491baece051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef7d1c4df5561dec95967442be8d33"><td class="memItemLeft" align="right" valign="top">TKey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a45ef7d1c4df5561dec95967442be8d33">CopyKeyBasedOnDenseIndexUnsafe</a> (size_t denseIndex) const noexcept</td></tr>
<tr class="memdesc:a45ef7d1c4df5561dec95967442be8d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the key out of the sparse set at the given dense index.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a45ef7d1c4df5561dec95967442be8d33">More...</a><br /></td></tr>
<tr class="separator:a45ef7d1c4df5561dec95967442be8d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd6bcd6e0ae8963a8b3f91a8a5d6418"><td class="memItemLeft" align="right" valign="top">TValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a4fd6bcd6e0ae8963a8b3f91a8a5d6418">CopyValueBasedOnDenseIndex</a> (size_t denseIndex) const</td></tr>
<tr class="memdesc:a4fd6bcd6e0ae8963a8b3f91a8a5d6418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value out of the sparse set at the given dense index.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a4fd6bcd6e0ae8963a8b3f91a8a5d6418">More...</a><br /></td></tr>
<tr class="separator:a4fd6bcd6e0ae8963a8b3f91a8a5d6418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0107cb8fb880eb0f1bb6b103c46398"><td class="memItemLeft" align="right" valign="top">TValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a3a0107cb8fb880eb0f1bb6b103c46398">CopyValueBasedOnDenseIndexUnsafe</a> (size_t denseIndex) const noexcept</td></tr>
<tr class="memdesc:a3a0107cb8fb880eb0f1bb6b103c46398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value out of the sparse set at the given dense index.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a3a0107cb8fb880eb0f1bb6b103c46398">More...</a><br /></td></tr>
<tr class="separator:a3a0107cb8fb880eb0f1bb6b103c46398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c93469e6e7394450cc20eb0cd72f67c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a3c93469e6e7394450cc20eb0cd72f67c">Length</a> () const noexcept</td></tr>
<tr class="memdesc:a3c93469e6e7394450cc20eb0cd72f67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current length of the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> based on the dense data.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a3c93469e6e7394450cc20eb0cd72f67c">More...</a><br /></td></tr>
<tr class="separator:a3c93469e6e7394450cc20eb0cd72f67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315d3245b4315b4c840eb8b8b37a0c99"><td class="memItemLeft" align="right" valign="top">TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a315d3245b4315b4c840eb8b8b37a0c99">operator[]</a> (TKey key) noexcept</td></tr>
<tr class="memdesc:a315d3245b4315b4c840eb8b8b37a0c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the value associated with the provided key.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a315d3245b4315b4c840eb8b8b37a0c99">More...</a><br /></td></tr>
<tr class="separator:a315d3245b4315b4c840eb8b8b37a0c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d90f055c2ada0998abcea91ade4f2"><td class="memItemLeft" align="right" valign="top">const TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#af94d90f055c2ada0998abcea91ade4f2">operator[]</a> (TKey key) const noexcept</td></tr>
<tr class="memdesc:af94d90f055c2ada0998abcea91ade4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the value associated with the provided key.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#af94d90f055c2ada0998abcea91ade4f2">More...</a><br /></td></tr>
<tr class="separator:af94d90f055c2ada0998abcea91ade4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0315a292a8a2e08837aa7898fb13ab42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; TKey, TValue &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a0315a292a8a2e08837aa7898fb13ab42">begin</a> () noexcept</td></tr>
<tr class="memdesc:a0315a292a8a2e08837aa7898fb13ab42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the beginning forward iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a0315a292a8a2e08837aa7898fb13ab42">More...</a><br /></td></tr>
<tr class="separator:a0315a292a8a2e08837aa7898fb13ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f4c4e66e5561424dd5b8876ef82739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; TKey, TValue &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a71f4c4e66e5561424dd5b8876ef82739">end</a> () noexcept</td></tr>
<tr class="memdesc:a71f4c4e66e5561424dd5b8876ef82739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ending forward iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a71f4c4e66e5561424dd5b8876ef82739">More...</a><br /></td></tr>
<tr class="separator:a71f4c4e66e5561424dd5b8876ef82739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830bd0cd04ac361a1407ed8744562624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; TKey, TValue &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a830bd0cd04ac361a1407ed8744562624">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a830bd0cd04ac361a1407ed8744562624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the beginning forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a830bd0cd04ac361a1407ed8744562624">More...</a><br /></td></tr>
<tr class="separator:a830bd0cd04ac361a1407ed8744562624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365c254a204ed6d122473d5db84ec1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; TKey, TValue &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a365c254a204ed6d122473d5db84ec1ab">end</a> () const noexcept</td></tr>
<tr class="memdesc:a365c254a204ed6d122473d5db84ec1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ending forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a365c254a204ed6d122473d5db84ec1ab">More...</a><br /></td></tr>
<tr class="separator:a365c254a204ed6d122473d5db84ec1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efe3710ffc1d41aee77578edf6a4b76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; TKey, TValue &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a8efe3710ffc1d41aee77578edf6a4b76">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a8efe3710ffc1d41aee77578edf6a4b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the beginning forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a8efe3710ffc1d41aee77578edf6a4b76">More...</a><br /></td></tr>
<tr class="separator:a8efe3710ffc1d41aee77578edf6a4b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55729816fddb8cf6517f3f1e3edf49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt; TKey, TValue &gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#aed55729816fddb8cf6517f3f1e3edf49">cend</a> () const noexcept</td></tr>
<tr class="memdesc:aed55729816fddb8cf6517f3f1e3edf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ending forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>.  <a href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#aed55729816fddb8cf6517f3f1e3edf49">More...</a><br /></td></tr>
<tr class="separator:aed55729816fddb8cf6517f3f1e3edf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKey, typename TValue&gt;<br />
class NovelRT::Ecs::SparseSet&lt; TKey, TValue &gt;</h3>

<p>A custom sparse set implementation designed at storing small, blittable types. </p>
<p>Please note that this storage type assumes that the component in question is a simple struct at all times. The value type should not be massively complex as there may be many copy instructions that are not SIMDifiable if the type is too complicated. The type TValue of the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> must be trivially copyable as defined by the C++ language reference. This is due to the internal language binding mechanisms of NovelRT, and is enforced by a check against std::is_trivally_copyable.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TKey</td><td>The type to use for the Key. </td></tr>
    <tr><td class="paramname">TValue</td><td>The type to use for the value. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a830bd0cd04ac361a1407ed8744562624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830bd0cd04ac361a1407ed8744562624">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;TKey, TValue&gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the beginning forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html" title="A non const iterator for traversing the keys and values of this particular SparseSet as tuple pairs.">SparseSet::Iterator</a> starting at the beginning. </dd></dl>

</div>
</div>
<a id="a0315a292a8a2e08837aa7898fb13ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0315a292a8a2e08837aa7898fb13ab42">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;TKey, TValue&gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html">Iterator</a> <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the beginning forward iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. While this method is not const, it does not modify the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> itself. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html" title="A non const iterator for traversing the keys and values of this particular SparseSet as tuple pairs.">SparseSet::Iterator</a> starting at the beginning. </dd></dl>

</div>
</div>
<a id="a8efe3710ffc1d41aee77578edf6a4b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efe3710ffc1d41aee77578edf6a4b76">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;TKey, TValue&gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the beginning forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html" title="A const iterator for traversing the keys and values of this particular SparseSet as tuple pairs in a ...">SparseSet::ConstIterator</a> starting at the beginning. </dd></dl>

</div>
</div>
<a id="aed55729816fddb8cf6517f3f1e3edf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed55729816fddb8cf6517f3f1e3edf49">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;TKey, TValue&gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ending forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html" title="A const iterator for traversing the keys and values of this particular SparseSet as tuple pairs in a ...">SparseSet::ConstIterator</a> starting at the end. </dd></dl>

</div>
</div>
<a id="a273330ecc7422f2791d83899e48e7e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273330ecc7422f2791d83899e48e7e9e">&#9670;&nbsp;</a></span>ContainsKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::ContainsKey </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the key is present within the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key is present. </dd>
<dd>
false if the key was not found. </dd></dl>

</div>
</div>
<a id="a56c7e95c1f6e5e8eb1a7f491baece051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c7e95c1f6e5e8eb1a7f491baece051">&#9670;&nbsp;</a></span>CopyKeyBasedOnDenseIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TKey <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::CopyKeyBasedOnDenseIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>denseIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the key out of the sparse set at the given dense index. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">denseIndex</td><td>The location in the dense data to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TKey The key at the specified dense location.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the specified dense index does not exist within the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ef7d1c4df5561dec95967442be8d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ef7d1c4df5561dec95967442be8d33">&#9670;&nbsp;</a></span>CopyKeyBasedOnDenseIndexUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TKey <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::CopyKeyBasedOnDenseIndexUnsafe </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>denseIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the key out of the sparse set at the given dense index. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method. This method assumes that the dense index is guaranteed to exist. If it does not then the behaviour is undefined. You can guarantee the existence of the dense index by comparing the dense index being used to the length of the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. See <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a3c93469e6e7394450cc20eb0cd72f67c" title="Gets the current length of the SparseSet based on the dense data.">SparseSet::Length</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">denseIndex</td><td>The location in the dense data to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TKey The key at the specified dense location. </dd></dl>

</div>
</div>
<a id="a4fd6bcd6e0ae8963a8b3f91a8a5d6418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd6bcd6e0ae8963a8b3f91a8a5d6418">&#9670;&nbsp;</a></span>CopyValueBasedOnDenseIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::CopyValueBasedOnDenseIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>denseIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the value out of the sparse set at the given dense index. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">denseIndex</td><td>The location in the dense data to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TValue The value at the specified dense location.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the specified dense index does not exist within the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a0107cb8fb880eb0f1bb6b103c46398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0107cb8fb880eb0f1bb6b103c46398">&#9670;&nbsp;</a></span>CopyValueBasedOnDenseIndexUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::CopyValueBasedOnDenseIndexUnsafe </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>denseIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the value out of the sparse set at the given dense index. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method. This method assumes that the dense index is guaranteed to exist. IF it does not then the behaviour is undefined. You can guarantee the existence of the dense index by comparing the dense index being used to the length of the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. See <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a3c93469e6e7394450cc20eb0cd72f67c" title="Gets the current length of the SparseSet based on the dense data.">SparseSet::Length</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">denseIndex</td><td>The location in the dense data to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TValue The value at the specified dense location. </dd></dl>

</div>
</div>
<a id="a365c254a204ed6d122473d5db84ec1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365c254a204ed6d122473d5db84ec1ab">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;TKey, TValue&gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ending forward const iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. While this method is not const, it does not modify the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> itself. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html" title="A non const iterator for traversing the keys and values of this particular SparseSet as tuple pairs.">SparseSet::Iterator</a> starting at the end. </dd></dl>

</div>
</div>
<a id="a71f4c4e66e5561424dd5b8876ef82739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f4c4e66e5561424dd5b8876ef82739">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">SparseSet</a>&lt;TKey, TValue&gt;::<a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html">Iterator</a> <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ending forward iterator state for this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </p>
<p>This function is under special formatting so that range-based for loops are supported. While this method is not const, it does not modify the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> itself. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set_1_1_iterator.html" title="A non const iterator for traversing the keys and values of this particular SparseSet as tuple pairs.">SparseSet::Iterator</a> starting at the end. </dd></dl>

</div>
</div>
<a id="a41eaf3e39edcd8243219a6cba720ea80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eaf3e39edcd8243219a6cba720ea80">&#9670;&nbsp;</a></span>Insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new key with paired with an initial value into the set. </p>
<p>All keys must be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The new key to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The initial value to associate with the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_novel_r_t_1_1_exceptions_1_1_duplicate_key_exception.html">Exceptions::DuplicateKeyException</a></td><td>when a duplicate key is provided. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is no memory left to allocate from the system to this <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c93469e6e7394450cc20eb0cd72f67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c93469e6e7394450cc20eb0cd72f67c">&#9670;&nbsp;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current length of the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> based on the dense data. </p>
<p>This is a pure method. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="af94d90f055c2ada0998abcea91ade4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94d90f055c2ada0998abcea91ade4f2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TValue&amp; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the value associated with the provided key. </p>
<p>While this method is not const, it does not modify the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> itself. Calling this without using the result has no effect and introduces overhead for calling a method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The target key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TValue&amp; The value as a const reference.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the specified key does not exist within the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a315d3245b4315b4c840eb8b8b37a0c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d3245b4315b4c840eb8b8b37a0c99">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue&amp; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the value associated with the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The target key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TValue&amp; The value as a mutable reference.</dd></dl>
<p>While this method is not const, it does not modify the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> itself. Calling this without using the result has no effect and introduces overhead for calling a method. This operator shares similar behaviour to that of std::vector. Specifically, if an invalid key is provided, then the resulting behaviour will be undefined. </p>

</div>
</div>
<a id="a4b85d25c0f3b52f08075c95b0875358a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b85d25c0f3b52f08075c95b0875358a">&#9670;&nbsp;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::Remove </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a given key and its associated value from the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the key is not present within the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34037a5d3a1d547dfef08a0f51405d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34037a5d3a1d547dfef08a0f51405d49">&#9670;&nbsp;</a></span>TryInsert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::TryInsert </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a new key paired with an initial value into the set. </p>
<p>All keys must be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The new key to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The initial value to associate with the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true when the pair is successfully inserted. </dd>
<dd>
false when the pair could not be inserted as dictated by <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a273330ecc7422f2791d83899e48e7e9e" title="Checks if the key is present within the SparseSet.">SparseSet::ContainsKey</a>. </dd></dl>

</div>
</div>
<a id="a8ccd7c783239892626a5f3ea6fa0eaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccd7c783239892626a5f3ea6fa0eaab">&#9670;&nbsp;</a></span>TryRemove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey , typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html">NovelRT::Ecs::SparseSet</a>&lt; TKey, TValue &gt;::TryRemove </td>
          <td>(</td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to remove the given key from the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html" title="A custom sparse set implementation designed at storing small, blittable types.">SparseSet</a> with additional safety checks to ensure it is an exceptionless operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key was successfully removed. </dd>
<dd>
false if <a class="el" href="class_novel_r_t_1_1_ecs_1_1_sparse_set.html#a273330ecc7422f2791d83899e48e7e9e" title="Checks if the key is present within the SparseSet.">SparseSet::ContainsKey</a> returns false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/NovelRT/NovelRT/include/NovelRT/Ecs/<a class="el" href="_sparse_set_8h_source.html">SparseSet.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
