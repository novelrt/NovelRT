<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NovelRT: NovelRT::Ecs::ComponentCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="novel-chan-header_doxy.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NovelRT
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">NovelRT game engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>NovelRT</b></li><li class="navelem"><a class="el" href="namespace_novel_r_t_1_1_ecs.html">Ecs</a></li><li class="navelem"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html">ComponentCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_novel_r_t_1_1_ecs_1_1_component_cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NovelRT::Ecs::ComponentCache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores all <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instances currently initialised for this instance of the ECS.  
 <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_component_cache_8h_source.html">ComponentCache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad332c75b627b2a13a428b0786c0515f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#ad332c75b627b2a13a428b0786c0515f4">ComponentCache</a> (size_t poolSize) noexcept</td></tr>
<tr class="memdesc:ad332c75b627b2a13a428b0786c0515f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html" title="Stores all ComponentBuffer instances currently initialised for this instance of the ECS.">ComponentCache</a> with a given thread pool size.  <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#ad332c75b627b2a13a428b0786c0515f4">More...</a><br /></td></tr>
<tr class="separator:ad332c75b627b2a13a428b0786c0515f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158e1a6a03d8e5f0ec4800af940fe40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_atom.html">ComponentTypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#a9158e1a6a03d8e5f0ec4800af940fe40">RegisterComponentTypeUnsafe</a> (size_t sizeOfDataType, const void *deleteInstructionState, const std::function&lt; void(void *, const void *, size_t)&gt; &amp;componentUpdateLogic)</td></tr>
<tr class="memdesc:a9158e1a6a03d8e5f0ec4800af940fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new component type and stores it internally.  <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#a9158e1a6a03d8e5f0ec4800af940fe40">More...</a><br /></td></tr>
<tr class="separator:a9158e1a6a03d8e5f0ec4800af940fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d01161c9e5a2df0a005948df02af02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21d01161c9e5a2df0a005948df02af02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#a21d01161c9e5a2df0a005948df02af02">RegisterComponentType</a> (T deleteInstructionState)</td></tr>
<tr class="memdesc:a21d01161c9e5a2df0a005948df02af02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new component type to the cache.  <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#a21d01161c9e5a2df0a005948df02af02">More...</a><br /></td></tr>
<tr class="separator:a21d01161c9e5a2df0a005948df02af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7326bfc772626aa957f1f2609ac3815"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#af7326bfc772626aa957f1f2609ac3815">GetComponentBufferById</a> (<a class="el" href="class_novel_r_t_1_1_atom.html">ComponentTypeId</a> id) const</td></tr>
<tr class="memdesc:af7326bfc772626aa957f1f2609ac3815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the memory container associated with this ID without type information.  <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#af7326bfc772626aa957f1f2609ac3815">More...</a><br /></td></tr>
<tr class="separator:af7326bfc772626aa957f1f2609ac3815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521529d761b34fd344d7bc1689a41585"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a521529d761b34fd344d7bc1689a41585"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">ComponentBuffer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#a521529d761b34fd344d7bc1689a41585">GetComponentBuffer</a> ()</td></tr>
<tr class="memdesc:a521529d761b34fd344d7bc1689a41585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instance that manages the specified component type.  <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#a521529d761b34fd344d7bc1689a41585">More...</a><br /></td></tr>
<tr class="separator:a521529d761b34fd344d7bc1689a41585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ec131e77b53d1c3ab17ed5c99dde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#ac73ec131e77b53d1c3ab17ed5c99dde5">PrepAllBuffersForNextFrame</a> (const std::vector&lt; <a class="el" href="class_novel_r_t_1_1_atom.html">EntityId</a> &gt; &amp;entitiesToDelete) noexcept</td></tr>
<tr class="memdesc:ac73ec131e77b53d1c3ab17ed5c99dde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares all <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instances for the next update cycle.  <a href="class_novel_r_t_1_1_ecs_1_1_component_cache.html#ac73ec131e77b53d1c3ab17ed5c99dde5">More...</a><br /></td></tr>
<tr class="separator:ac73ec131e77b53d1c3ab17ed5c99dde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores all <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instances currently initialised for this instance of the ECS. </p>
<p>You should not be instantiating this yourself in a regular setup. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad332c75b627b2a13a428b0786c0515f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad332c75b627b2a13a428b0786c0515f4">&#9670;&nbsp;</a></span>ComponentCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NovelRT::Ecs::ComponentCache::ComponentCache </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poolSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_cache.html" title="Stores all ComponentBuffer instances currently initialised for this instance of the ECS.">ComponentCache</a> with a given thread pool size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poolSize</td><td>The amount of worker threads to allocate for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a521529d761b34fd344d7bc1689a41585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521529d761b34fd344d7bc1689a41585">&#9670;&nbsp;</a></span>GetComponentBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html">ComponentBuffer</a>&lt;T&gt; NovelRT::Ecs::ComponentCache::GetComponentBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instance that manages the specified component type. </p>
<p>This is a pure method. Retrieving the <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> and then discarding it has no effect and introduces the overhead of a method call.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type that the returned <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> manages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ComponentBuffer&lt;T&gt; The <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> for T by reference.</dd></dl>
<p>@exceptions std::out_of_range if the specified component type has not been registered. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_cache_a521529d761b34fd344d7bc1689a41585_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_cache_a521529d761b34fd344d7bc1689a41585_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_cache_a521529d761b34fd344d7bc1689a41585_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_cache_a521529d761b34fd344d7bc1689a41585_icgraph">
<area shape="rect" title="Get the ComponentBuffer instance that manages the specified component type." alt="" coords="232,39,460,80"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_catalogue.html#a6efa85c775b1bc950ae4a610f60dc3b8" title="Gets a view into the ComponentCache for the specified component type based on the context of the Cata..." alt="" coords="5,5,184,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_catalogue.html#afdd2ce085f7e733c3c7c7091f30e5847" title="Gets a variadic tuple of views into the ComponentCache for the specified component types based on the..." alt="" coords="5,71,184,112"/>
</map>
</div>

</div>
</div>
<a id="af7326bfc772626aa957f1f2609ac3815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7326bfc772626aa957f1f2609ac3815">&#9670;&nbsp;</a></span>GetComponentBufferById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a>&gt; NovelRT::Ecs::ComponentCache::GetComponentBufferById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_novel_r_t_1_1_atom.html">ComponentTypeId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the memory container associated with this ID without type information. </p>
<p>TODO: docs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac73ec131e77b53d1c3ab17ed5c99dde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73ec131e77b53d1c3ab17ed5c99dde5">&#9670;&nbsp;</a></span>PrepAllBuffersForNextFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NovelRT::Ecs::ComponentCache::PrepAllBuffersForNextFrame </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_novel_r_t_1_1_atom.html">EntityId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entitiesToDelete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares all <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instances for the next update cycle. </p>
<p>This method is not thread safe. It should also not be explicitly called by the end user in a regular ECS setup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entitiesToDelete</td><td>All entities that were explicitly pushed for deletion in the last update cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21d01161c9e5a2df0a005948df02af02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d01161c9e5a2df0a005948df02af02">&#9670;&nbsp;</a></span>RegisterComponentType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NovelRT::Ecs::ComponentCache::RegisterComponentType </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>deleteInstructionState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new component type to the cache. </p>
<p>This method allocates a new <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> instance for T and stores it internally. This method is not thread safe. as a result, all components should be registered before any iterations of the ECS are performed. If this is executed concurrently, it is highly likely you will end up with a segfault.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The component type to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteInstructionState</td><td>The instruction state for the component used for recognising a delete instruction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>when a <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> could not be allocated in memory for the given component type. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_novel_r_t_1_1_ecs_1_1_component_cache_a21d01161c9e5a2df0a005948df02af02_icgraph.png" border="0" usemap="#class_novel_r_t_1_1_ecs_1_1_component_cache_a21d01161c9e5a2df0a005948df02af02_icgraph" alt=""/></div>
<map name="class_novel_r_t_1_1_ecs_1_1_component_cache_a21d01161c9e5a2df0a005948df02af02_icgraph" id="class_novel_r_t_1_1_ecs_1_1_component_cache_a21d01161c9e5a2df0a005948df02af02_icgraph">
<area shape="rect" title="Registers a new component type to the cache." alt="" coords="300,5,528,47"/>
<area shape="rect" href="class_novel_r_t_1_1_ecs_1_1_configurator.html#a37601dc5c40e4a0f908294164eed7d98" title="Creates the ECS instance and registers component types to it." alt="" coords="5,5,252,47"/>
</map>
</div>

</div>
</div>
<a id="a9158e1a6a03d8e5f0ec4800af940fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9158e1a6a03d8e5f0ec4800af940fe40">&#9670;&nbsp;</a></span>RegisterComponentTypeUnsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_novel_r_t_1_1_atom.html">ComponentTypeId</a> NovelRT::Ecs::ComponentCache::RegisterComponentTypeUnsafe </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeOfDataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>deleteInstructionState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(void *, const void *, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>componentUpdateLogic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a new component type and stores it internally. </p>
<p>This is considered an unsafe operation. If the data stored in deleteInstructionState does not match with the specified size, or if the type being used is not trivially copyable as defined by the C++ language reference, then the behaviour is undefined. See <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> and std::is_trivially_copyable for more information.</p>
<p>The returned ID cannot be discarded. If the value is discarded, then the container is lost permanently, effectively causing a memory leak.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeOfDataType</td><td>The size of the object type, in bytes. </td></tr>
    <tr><td class="paramname">deleteInstructionState</td><td>The object state that indicates that the component should be deleted. </td></tr>
    <tr><td class="paramname">componentUpdateLogic</td><td>The function to use for concurrent update consolidation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ComponentTypeId the ID of the new component type and associated <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer_memory_container.html">ComponentBufferMemoryContainer</a> instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>when a <a class="el" href="class_novel_r_t_1_1_ecs_1_1_component_buffer.html" title="A storage type that manages the storage and modification of the given type concurrently.">ComponentBuffer</a> could not be allocated in memory for the given component type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/NovelRT/NovelRT/include/NovelRT/Ecs/<a class="el" href="_component_cache_8h_source.html">ComponentCache.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
